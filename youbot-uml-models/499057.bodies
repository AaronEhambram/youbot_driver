class JointTrajectoryController
!!!958705.cpp!!!	JointTrajectoryController(inout joint : YouBotJoint)
  ethercatMaster = static_cast<EthercatMasterWithThread*>(&(EthercatMaster::getInstance()));
          
  GearRatio gearR;
  joint.getConfigurationParameter(gearR);
  gearR.getParameter(gearRatio);
  
!!!951537.cpp!!!	setTrajectory(in positions : std::vector< quantity<plane_angle> >, in velocities : std::vector< quantity<angular_velocity> >, in accelerations : std::vector< quantity<angular_acceleration> >) : void
  //check data
  // vel != 0
  // acc != 0
  // position in limits
  //if(velocity == 0 *radian_per_second)
  //  return;
  JointSensedAngle currentPosition;
  quantity<plane_angle> position_delta;
  joint.getData(currentPosition);
  
  JointSensedVelocity currentVelocity;
  quantity<si::angular_velocity> velocity_current;
  joint.getData(currentVelocity);
  
  std::list<int32> targetVelocities;
  
  for(unsigned int i = 0; i< positions.size(); i++) {
    if(i == 0){
      position_delta = positions[i] - currentPosition.angle; 
      velocity_current = currentVelocity.angularVelocity;
    }else{
      position_delta = positions[i] - positions[i-1];
      velocity_current = velocities[i-1];
  }
    LOG(error) << velocity_current;
    
    this->calculateVelocities(position_delta, velocities[i], velocity_current,  accelerations[i], targetVelocities);
  }
  
  //DEBUG: just to stop the joint
  targetVelocities.push_back(0);
  
  
  unsigned int jointNumber = joint.getJointNumber();
  
  ethercatMaster->setTrajectoryVelocities(targetVelocities, jointNumber);
  
!!!952049.cpp!!!	isTrajectoryControllerActive() : bool
  return false;
!!!958577.cpp!!!	calculateVelocities(in position_delta : quantity<plane_angle>, in velocity : quantity<angular_velocity>, in velocity_current : quantity<angular_velocity>, in acceleration : quantity<angular_acceleration>, out targetVelocities : std::list<int32>) : void

  quantity<boost::units::si::time> totalTime;
  totalTime = (position_delta/velocity); //+ (velocity/(acceleration * 2.0)); //old
  
 // totalTime = (position_delta/velocity) + ((2.0*velocity*velocity_delta + (velocity_delta*velocity_delta))/(acceleration * 2.0 * velocity));
  
 // totalTime = (position_delta/velocity) + (velocity_delta/acceleration);
  
 // LOG(error) << "second part: " <<((2.0*velocity*velocity_delta + (velocity_delta*velocity_delta))/(acceleration * 2.0 * velocity));
  
  quantity<boost::units::si::time> accelerationTime;
  accelerationTime = (velocity - velocity_current)/acceleration;
  totalTime = totalTime + (accelerationTime/2.0);
  
  std::cout << "totalTime: " << totalTime << std::endl;
  std::cout << "accelerationTime: " << accelerationTime << std::endl;
  
  int totalTimeMili = (int)round(totalTime.value() * 1000);
  int accelerationTimeMili = (int)round(accelerationTime.value() * 1000);
  int32 vel;
  
  double targetVelocity; // radian_per_seconds
  
  for(int i= 1; i<=totalTimeMili;i++){
    if(i < accelerationTimeMili){
      targetVelocity = velocity_current.value() + (acceleration.value()) * ((double)i/1000.0);
     // LOG(error) << "targetVelocity ACC: " <<targetVelocity;
    }else{
      targetVelocity = velocity.value();
    }
    vel = (int32) round((targetVelocity / (gearRatio * 2.0 * M_PI)) * 60.0);
   // LOG(error) << "targetVelocity: " <<vel;
    targetVelocities.push_back(vel); //randiand per second in rpm
    ///TODO check inverse movement direction parameter
  }
